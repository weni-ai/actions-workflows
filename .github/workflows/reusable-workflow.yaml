name: Build, push to registry and deploy

permissions:
  id-token: write
  contents: read

on:
  workflow_call:
    inputs:
      image_arch:
        required: false
        type: string
        default: ""
      image_repository:
        required: true
        type: string
      image_tags:
        required: false
        type: string
        default: |
          type=ref,event=tag
      image_tag_latest_by_environment:
        required: false
        type: string
        default: "false"
      image_tag_prefix:
        required: false
        type: string
        default: ""
      image_tag_prefix_onlatest:
        required: false
        type: string
        default: "false"
      image_latest:
        required: false
        type: string
        default: "false"
      build_args:
        required: false
        type: string
        default: ""
      build_context:
        required: false
        type: string
        default: "."
      debug:
        required: false
        type: string
        default: ""
      default_environment:
        required: false
        type: string
        default: "production"
      dockerfile:
        required: false
        type: string
        default: Dockerfile
      target_application:
        required: false
        type: string
        default: ""
      target_repository:
        required: false
        type: string
        default: ""
      deploy_type:
        required: false
        type: string
        default: "kubernetes"
      target_repository_branch:
        required: false
        type: string
        default: "main"
      target_patch_file:
        required: false
        type: string
        default: "deployment.json"
      aws_region:
        required: false
        type: string
        default: "us-east-1"
      aws_ssm_name:
        required: false
        type: string
        default: "/cloud/github/TOKEN"

      # kludges
      kludge_webapp_secret_enable:
        required: false
        type: boolean
        default: false

    secrets:
      ROLE_ARN:
        required: false
      REGISTRY_ECR:
        required: false
      REGISTRY_USERNAME:
        required: false
      REGISTRY_TOKEN:
        required: false
      DEVOPS_GITHUB_PERMANENT_TOKEN:
        required: false

env:
  DOCKER_IMAGE: ${{ secrets.REGISTRY_ECR }}/${{ inputs.image_repository }}

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      image_by_environment: ${{ steps.setup.outputs.image_by_environment }}
      environment: ${{ steps.setup.outputs.DEPLOY_ENVIRONMENT }}
      use_role: ${{ steps.setup.outputs.USE_ROLE }}
      digests_prefix: ${{ steps.setup.outputs.DIGESTS_PREFIX }}
      image_arch: ${{ steps.setup.outputs.image_arch }}
      build_args: ${{ steps.setup.outputs.build_args }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        if: ${{ env.use_role != '' }}
        env:
          use_role: ${{ secrets.ROLE_ARN }}
        with:
          audience: sts.amazonaws.com
          role-session-name: ${{ github.run_id }}
          role-to-assume: ${{ secrets.ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}

      - name: Set VCS token
        id: set-vcs-token
        run: |
          cat<<<"VCS_TOKEN=$(
            if [ "${{ secrets.ROLE_ARN }}" ] ; then
              aws ssm get-parameter --with-decryption \
                --name "${{ inputs.aws_ssm_name }}" \
                | jq -r .Parameter.Value
            elif [ "${{ secrets.DEVOPS_GITHUB_PERMANENT_TOKEN }}" ] ; then
              cat<<<"${{ secrets.DEVOPS_GITHUB_PERMANENT_TOKEN }}"
            fi
          )" >> "${GITHUB_OUTPUT}"
        env:
          AWS_DEFAULT_REGION: ${{ inputs.aws_region }}

      - name: Download webapp secret
        uses: actions/checkout@master
        if: inputs.kludge_webapp_secret_enable
        with:
          ref: main
          repository: "weni-ai/webapp-secret"
          token: "${{ steps.set-vcs-token.outputs.VCS_TOKEN }}"
          path: ./webapp-secret/

      - name: Set outputs
        id: setup
        env:
          BUILD_ARGS: ${{ inputs.build_args }}
        run: |
          TAG="$( echo "${GITHUB_REF}" | cut -d'/' -f3 )"
          if grep -qs -e '^.*.*-develop' <<< "${TAG}" ; then
            echo "Found environment: DEVELOP - ${TAG}"
            echo "DEPLOY_ENVIRONMENT=develop" | tee "${GITHUB_OUTPUT}"
            export "DEPLOY_ENVIRONMENT=develop"
          elif grep -qs -e '^.*.*-staging' <<< "${TAG}" ; then
            echo "Found environment: STAGING - ${TAG}"
            echo "DEPLOY_ENVIRONMENT=staging" | tee -a "${GITHUB_OUTPUT}"
            export "DEPLOY_ENVIRONMENT=staging"
          elif grep -qs -e '^.*.*' <<< "${TAG}" ; then
            echo "No environment found, assuming: ${{ inputs.default_environment }} - ${TAG}"
            echo "DEPLOY_ENVIRONMENT=${{ inputs.default_environment }}" | tee -a "${GITHUB_OUTPUT}"
            export "DEPLOY_ENVIRONMENT=${{ inputs.default_environment }}"
          else
            echo 'Not a valid tag. Skipping...'
            exit 1
          fi
          export GITHUB_REPOSITORY_NAME="${GITHUB_REPOSITORY#$GITHUB_REPOSITORY_OWNER/}"
          {
            if [ "${{ secrets.ROLE_ARN }}" ] ; then
              echo "USE_ROLE=true" | tee -a "${GITHUB_OUTPUT}"
            fi
            if [ "${{ inputs.image_tag_latest_by_environment }}" = "true" ] ; then
              echo "image_by_environment=type=raw,latest-${DEPLOY_ENVIRONMENT}" | tee -a "${GITHUB_OUTPUT}"
            fi
            echo "DIGESTS_PREFIX=digests-$( echo "${DOCKER_IMAGE}" | tr './' '-' )" | tee -a "${GITHUB_OUTPUT}"
            echo 'image_arch<<EOFenv'
            if [ "${{ inputs.image_arch }}" = "" ] ; then
              if [ "${{ github.repository_visibility }}" = "private" ] ; then
                echo '[{"platform":"linux/arm64","runner":"ubuntu-latest"},{"platform":"linux/amd64","runner":"ubuntu-latest"}]'
              else
                echo '[{"platform":"linux/arm64","runner":"ubuntu-24.04-arm"},{"platform":"linux/amd64","runner":"ubuntu-latest"}]'
              fi
            else
              echo '${{ inputs.image_arch }}'
            fi
            echo EOFenv

            # Set build args
            echo 'BUILD_ARGS<<EOFenv'
            if [ -r "webapp-secret/${GITHUB_REPOSITORY_NAME}/${DEPLOY_ENVIRONMENT}/env" ] ; then
              cat "webapp-secret/${GITHUB_REPOSITORY_NAME}/${DEPLOY_ENVIRONMENT}/env"
            fi
            if [ "${BUILD_ARGS}" ] ; then
              cat <<<"${BUILD_ARGS}"
            fi
            echo EOFenv
          } | tee -a "${GITHUB_OUTPUT}"

          {
            echo "### Workflow Outputs"
            echo "| Variable             | Description     |"
            echo "| -------------------- | --------------- |"
            echo "| digests_prefix       | Prefix used in digests artifact |"
            echo "| environment          | Enviroment identifier to build and/or deploy. Based on tags. |"
            echo "| image_by_environment | Extra images to build based on enviroment |"
            echo "| use_role             | If true, use role for AWS access |"
            echo "| build_args           | build args to be used when building the container |"
          } | tee -a "${GITHUB_STEP_SUMMARY}"

  build_and_push:
    needs:
      - setup
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.setup.outputs.image_arch) }}
    runs-on: ${{ matrix.runner }}
    outputs:
      version: ${{ steps.meta.outputs.version }}
    steps:
      - name: Set variables
        run: |
          platform=${{ matrix.platform }}
          echo "PLATFORM_PAIR=${platform//\//-}" | tee -a "${GITHUB_ENV}"

      - name: Check out the repo
        uses: actions/checkout@v4

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            ${{ inputs.image_tags }}
            ${{ needs.setup.outputs.image_by_environment }}
          flavor: |
            latest=${{ inputs.image_latest }}
            prefix=${{ inputs.image_tag_prefix }},onlatest=${{ inputs.image_tag_prefix_onlatest }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        if: needs.setup.outputs.use_role == 'true'
        with:
          audience: sts.amazonaws.com
          role-session-name: ${{ github.run_id }}
          role-to-assume: ${{ secrets.ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}

      - name: Login to Registry with aws role
        uses: docker/login-action@v3
        if: github.event_name != 'pull_request' && needs.setup.outputs.use_role == 'true'
        with:
          registry: ${{ secrets.REGISTRY_ECR }}

      - name: Login to Registry with login and password
        uses: docker/login-action@v3
        if: github.event_name != 'pull_request' && needs.setup.outputs.use_role != 'true'
        with:
          registry: ${{ secrets.REGISTRY_ECR }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        if: matrix.platform != 'linux/amd64' && matrix.runner == 'ubuntu-latest'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Docker Image
        id: build
        uses: docker/build-push-action@v6
        with:
          provenance: false # fix
          #sbom: false
          file: ${{ inputs.dockerfile }}
          context: ${{ inputs.build_context }}
          build-args: |
            ${{ needs.setup.outputs.build_args }}
            PLATFORM_PAIR=${{ env.PLATFORM_PAIR }}
          annotations: ${{ steps.meta.outputs.annotations }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: ${{ matrix.platform }}
          outputs: type=image,name=${{ env.DOCKER_IMAGE }},push-by-digest=true,name-canonical=true,push=true

      - name: Export digest and push tag
        env:
          SOURCE_IMAGE: "${{ env.DOCKER_IMAGE }}@${{ steps.build.outputs.digest }}"
          TARGET_IMAGE: "${{ env.DOCKER_IMAGE }}:${{ steps.meta.outputs.version }}-${{ env.PLATFORM_PAIR }}"
        run: |
          if [ "${{ inputs.debug }}" = "true" ] ; then
            set -xv
          fi
          mkdir -p ${{ runner.temp }}/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "${{ runner.temp }}/digests/${digest#sha256:}"
          docker pull "${{ env.SOURCE_IMAGE }}"
          docker tag "${{ env.SOURCE_IMAGE }}" "${{ env.TARGET_IMAGE }}"
          docker push "${{ env.TARGET_IMAGE }}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: ${{ needs.setup.outputs.digests_prefix }}-${{ steps.meta.outputs.version }}-${{ env.PLATFORM_PAIR }}
          path: ${{ runner.temp }}/digests/*
          if-no-files-found: error
          retention-days: 1

  merge:
    runs-on: ubuntu-latest
    needs:
      - setup
      - build_and_push
    steps:
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            ${{ inputs.image_tags }}
            ${{ needs.setup.outputs.image_by_environment }}
          flavor: |
            latest=${{ inputs.image_latest }}
            prefix=${{ inputs.image_tag_prefix }},onlatest=${{ inputs.image_tag_prefix_onlatest }}

      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: ${{ runner.temp }}/digests
          pattern: ${{ needs.setup.outputs.digests_prefix }}-${{ steps.meta.outputs.version }}-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        if: needs.setup.outputs.use_role == 'true'
        with:
          audience: sts.amazonaws.com
          role-session-name: ${{ github.run_id }}
          role-to-assume: ${{ secrets.ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}

      - name: Login to Registry with role
        uses: docker/login-action@v3
        if: github.event_name != 'pull_request' && needs.setup.outputs.use_role == 'true'
        with:
          registry: ${{ secrets.REGISTRY_ECR }}

      - name: Login to Registry with login and password
        uses: docker/login-action@v3
        if: github.event_name != 'pull_request' && needs.setup.outputs.use_role != 'true'
        with:
          registry: ${{ secrets.REGISTRY_ECR }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      - name: Create manifest list and push
        working-directory: ${{ runner.temp }}/digests
        run: |
          if [ "${{ inputs.debug }}" = "true" ] ; then
            set -xv
          fi
          docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "${DOCKER_METADATA_OUTPUT_JSON}") \
            $(printf '${{ env.DOCKER_IMAGE }}@sha256:%s ' *)

      - name: Inspect image
        working-directory: ${{ runner.temp }}/digests
        if: inputs.debug == 'true'
        run: |
          for x in $(jq -cr '.tags | join(" ")' <<< "${DOCKER_METADATA_OUTPUT_JSON}"); do
            echo docker buildx imagetools inspect "${x}"
            docker buildx imagetools inspect "${x}"
          done

  deploy:
    if: inputs.target_repository != ''
    env:
      DEPLOY_APPLICATION: ${{ inputs.target_application }}
      DEPLOY_REPOSITORY: ${{ inputs.target_repository }}
      DEPLOY_PATCH_TARGET: ${{ inputs.target_patch_file }}
      DEPLOY_REPOSITORY_BRANCH: ${{ inputs.target_repository_branch }}
    needs:
      - setup
      - merge
      - build_and_push
    #runs-on: ubuntu-22.04
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        if: needs.setup.outputs.use_role == 'true'
        with:
          audience: sts.amazonaws.com
          role-session-name: ${{ github.run_id }}
          role-to-assume: ${{ secrets.ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}

      - name: Set VCS token
        id: set-vcs-token
        run: |
          echo "VCS_TOKEN=$(
            if [ "${{ needs.setup.outputs.use_role }}" = "true" ] ; then
              aws ssm get-parameter --with-decryption \
                --name "${{ inputs.aws_ssm_name }}" \
                | jq -r .Parameter.Value
            elif [ "${{ secrets.DEVOPS_GITHUB_PERMANENT_TOKEN }}" ] ; then
              cat<<<"${{ secrets.DEVOPS_GITHUB_PERMANENT_TOKEN }}"
            fi
          )" >> "${GITHUB_OUTPUT}"
        env:
          AWS_DEFAULT_REGION: ${{ inputs.aws_region }}

      - name: Check out deploy repository
        uses: actions/checkout@v3
        with:
          ref: ${{ env.DEPLOY_REPOSITORY_BRANCH }}
          repository: ${{ env.DEPLOY_REPOSITORY }}
          token: ${{ steps.set-vcs-token.outputs.VCS_TOKEN }}
          path: ./deploy-repository/

      - name: Update image on kubernetes manifests
        if: inputs.deploy_type == 'kubernetes'
        working-directory: ./deploy-repository/${{ env.DEPLOY_APPLICATION }}
        env:
          IMAGE_TAG: ${{ env.DOCKER_IMAGE }}:${{ needs.build_and_push.outputs.version }}
          IMAGE_ARCH: ${{ fromJson(needs.setup.outputs.image_arch)[0].platform }}
        run: |
          if [ "${{ inputs.debug }}" = "true" ] ; then
            set -xv
          fi

          which jq > /dev/null 2>&1 || ( sudo apt update; sudo apt install -y jq )

          extver() {
            echo "$1" | sed s'/^.*[v:-]\([0-9]*\.[0-9]*\.[0-9]*\).*$/\1/'g | head -n1
          }

          verlte() {
            [ "$1" = "$(echo -e "$1\n$2" | sort -V | head -n1)" ]
          }

          DEPLOY_ENV_TARGET=$(
            echo ${{ needs.build_and_push.outputs.version }} | grep -Eo 'staging|develop' || echo 'production'
          )

          echo "Target environment: ${DEPLOY_ENV_TARGET}"

          if [ ! -d "${DEPLOY_ENV_TARGET}" ] || [ ! -r "${DEPLOY_ENV_TARGET}/kustomization.yaml" ] || [ ! -r "${DEPLOY_ENV_TARGET}/${{ env.DEPLOY_PATCH_TARGET }}" ]; then
            echo "${DEPLOY_ENV_TARGET}, ${DEPLOY_ENV_TARGET}/kustomization.yaml, or ${DEPLOY_ENV_TARGET}/${{ env.DEPLOY_PATCH_TARGET }}: Not readable, or neither one of those exists"
            exit 1
          else
            CURRENT_IMAGE=$(
              cat "${DEPLOY_ENV_TARGET}/${{ env.DEPLOY_PATCH_TARGET }}" \
                | jq -r '.[] | select(.path == "/spec/template/spec/containers/0/image") | .value'
            )
            CURRENT_VERSION=$(extver "${CURRENT_IMAGE}")
            TARGET_VERSION=$(extver "${{ env.IMAGE_TAG }}")

            echo "Replacing the following image:"
            echo "  Image: ${CURRENT_IMAGE%%:*}"
            echo "  Current version: ${CURRENT_VERSION}"
            echo "  Target version: ${TARGET_VERSION}"

            if verlte "${CURRENT_VERSION}" "${TARGET_VERSION}"; then
              NEW_CONFIG=$(
                jq --arg imageTag "${{ env.IMAGE_TAG }}" '(.. | select(.path == "/spec/template/spec/containers/0/image")?) += {value: $imageTag }' "${DEPLOY_ENV_TARGET}/${{ env.DEPLOY_PATCH_TARGET }}"
              )
              echo "New configuration:"
              echo "${NEW_CONFIG}" | tee "${DEPLOY_ENV_TARGET}/${{ env.DEPLOY_PATCH_TARGET }}"
            else
              echo "Version in file is greater than build, skipping update yaml"
            fi
          fi

      - name: Update image on terraform one.yaml
        if: inputs.deploy_type == 'terraform'
        working-directory: ./deploy-repository/
        env:
          IMAGE_TAG: ${{ env.DOCKER_IMAGE }}:${{ needs.build_and_push.outputs.version }}
          IMAGE_ARCH: ${{ fromJson(needs.setup.outputs.image_arch)[0].platform }}
        run: |
          if [ "${{ inputs.debug }}" = "true" ] ; then
            set -xv
          fi

          which jq > /dev/null 2>&1 || ( sudo apt update; sudo apt install -y jq )

          extver() {
            echo "$1" | sed s'/^.*[v:-]\([0-9]*\.[0-9]*\.[0-9]*\).*$/\1/'g | head -n1
          }

          verlte() {
            [ "$1" = "$(echo -e "$1\n$2" | sort -V | head -n1)" ]
          }

          if [ ! -r "one.yaml" ] ; then
            echo "one.yaml: Not readable, or neither one of those exists"
            exit 1
          fi

          export ENVIRONMENT_ONE=$(
            yq '.workspaces | keys | .[] ' -r < one.yaml \
              | fgrep '${{needs.setup.outputs.environment}}' \
              | head -n1
          )

          for APPLICATION_NAME in ${{ inputs.target_application }} ; do
            OLD_IMAGE=$(
              cat "one.yaml" \
                | yq '.workspaces.'"${ENVIRONMENT_ONE}"'.lambda."'"${APPLICATION_NAME}"'".image' -r
            )
            OLD_VERSION=$(
              echo "${OLD_IMAGE}" \
                | sed s'/^.*[v:-]\([0-9]*\.[0-9]*\.[0-9]*\).*$/\1/'g \
                | head -n1
            )

            echo "Target environment: ${{needs.setup.outputs.environment}}"

            echo "Replacing the following image:"
            echo "  Image: ${DOCKER_IMAGE%%:*}"
            echo "  Current version: ${OLD_VERSION}"
            echo "  Target version: ${{ needs.build_and_push.outputs.version }}"

            echo "Old image version to compare: ${OLD_VERSION}<=${{ needs.build_and_push.outputs.version }}"
            if verlte "${OLD_VERSION}" "${{ needs.build_and_push.outputs.version }}" || [[ ! "${OLD_VERSION}" =~ [0-9]+\.[0-9]+\.[0-9]+ ]] ; then
              echo 'New configurations:'
              new_configuration=$(
                yq \
                  '.workspaces."'"${ENVIRONMENT_ONE}"'".lambda."'"${APPLICATION_NAME}"'".image = "'"${{env.IMAGE_TAG}}-${IMAGE_ARCH//\//-}"'"' \
                  --output-format=yaml < one.yaml \
                  | sed s'/!!merge //'g
              )
              echo "${new_configuration}"
              echo "${new_configuration}" > "one.yaml"
            else
              echo "Version in file is greater than build, skipping update yaml"
            fi
          done

      - name: Commit & Push changes
        uses: actions-js/push@master
        with:
          github_token: ${{ steps.set-vcs-token.outputs.VCS_TOKEN }}
          repository: ${{ env.DEPLOY_REPOSITORY }}
          directory: ./deploy-repository/
          branch: ${{ env.DEPLOY_REPOSITORY_BRANCH }}
          message: "From ${{github.repository}}: ${{ github.workflow }}"
