name: Build, push to registry and deploy

permissions:
  id-token: write
  contents: read

on:
  workflow_call:
    inputs:
      image_arch:
        required: false
        type: string
        default: |
          [
            {
              "platform": "linux/arm64",
              "runner": "ubuntu-24.04-arm"
            },
            {
              "platform": "linux/amd64",
              "runner": "ubuntu-latest"
            }
          ]
      image_repository:
        required: true
        type: string
      image_tags:
        required: false
        type: string
        default: |
          type=ref,event=tag
      image_tag_latest_by_environment:
        required: false
        type: string
        default: "false"
      image_tag_prefix:
        required: false
        type: string
        default: ""
      image_tag_prefix_onlatest:
        required: false
        type: string
        default: "false"
      image_latest:
        required: false
        type: string
        default: "false"
      build_args:
        required: false
        type: string
        default: ""
      build_context:
        required: false
        type: string
        default: "."
      debug:
        required: false
        type: string
        default: ""
      default_environment:
        required: false
        type: string
        default: "production"
      dockerfile:
        required: false
        type: string
        default: Dockerfile
      target_application:
        required: false
        type: string
        default: ""
      target_repository:
        required: false
        type: string
        default: ""
      target_repository_branch:
        required: false
        type: string
        default: "main"
      target_patch_file:
        required: false
        type: string
        default: "deployment.json"
      aws_region:
        required: false
        type: string
        default: "us-east-1"
      aws_ssm_name:
        required: false
        type: string
        default: "/cloud/github/TOKEN"
    secrets:
      ROLE_ARN:
        required: false
      REGISTRY_ECR:
        required: false
      REGISTRY_USERNAME:
        required: false
      REGISTRY_TOKEN:
        required: false
      DEVOPS_GITHUB_PERMANENT_TOKEN:
        required: true

env:
  DOCKER_IMAGE: ${{ secrets.REGISTRY_ECR }}/${{ inputs.image_repository }}

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      image_by_environment: ${{ steps.setup.outputs.image_by_environment }}
      use_role: ${{ steps.setup.outputs.USE_ROLE }}
      digests_prefix: ${{ steps.setup.outputs.DIGESTS_PREFIX }}
    steps:
      - name: Set outputs
        id: setup
        run: |
          TAG="$( echo "${GITHUB_REF}" | cut -d'/' -f3 )"
          if grep -qs -e '^.*.*-develop' <<< "${TAG}" ; then
            echo "Found environment: DEVELOP - ${TAG}"
            echo "DEPLOY_ENVIRONMENT=develop" | tee "${GITHUB_OUTPUT}"
            export "DEPLOY_ENVIRONMENT=develop"
          elif grep -qs -e '^.*.*-staging' <<< "${TAG}" ; then
            echo "Found environment: STAGING - ${TAG}"
            echo "DEPLOY_ENVIRONMENT=staging" | tee -a "${GITHUB_OUTPUT}"
            export "DEPLOY_ENVIRONMENT=staging"
          elif grep -qs -e '^.*.*' <<< "${TAG}" ; then
            echo "No environment found, assuming: ${{ inputs.default_environment }} - ${TAG}"
            echo "DEPLOY_ENVIRONMENT=${{ inputs.default_environment }}" | tee -a "${GITHUB_OUTPUT}"
            export "DEPLOY_ENVIRONMENT=${{ inputs.default_environment }}"
          else
            echo 'Not a valid tag. Skipping...'
            exit 1
          fi
          if [ "${{ secrets.ROLE_ARN }}" ] ; then
            echo "USE_ROLE=true" | tee -a "${GITHUB_OUTPUT}"
          fi
          if [ "${{ inputs.image_tag_latest_by_environment }}" = "true" ] ; then
            echo "image_by_environment=type=raw,latest-${DEPLOY_ENVIRONMENT}" | tee -a "${GITHUB_OUTPUT}"
          fi
          echo "DIGESTS_PREFIX=digests-$( echo "${DOCKER_IMAGE}" | tr './' '-' )" | tee -a "${GITHUB_OUTPUT}"

  build_and_push:
    needs:
      - setup
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(inputs.image_arch) }}
    runs-on: ${{ matrix.runner }}
    outputs:
      version: ${{ steps.meta.outputs.version }}
    steps:
      - name: Set variables
        run: |
          platform=${{ matrix.platform }}
          echo "PLATFORM_PAIR=${platform//\//-}" | tee -a "${GITHUB_ENV}"

      - name: Check out the repo
        uses: actions/checkout@v4

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            ${{ inputs.image_tags }}
            ${{ needs.setup.outputs.image_by_environment }}
          flavor: |
            latest=${{ inputs.image_latest }}
            prefix=${{ inputs.image_tag_prefix }},onlatest=${{ inputs.image_tag_prefix_onlatest }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        if: needs.setup.outputs.use_role == 'true'
        with:
          audience: sts.amazonaws.com
          role-session-name: ${{ github.run_id }}
          role-to-assume: ${{ secrets.ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}

      - name: Login to Registry with aws role
        uses: docker/login-action@v3
        if: github.event_name != 'pull_request' && needs.setup.outputs.use_role == 'true'
        with:
          registry: ${{ secrets.REGISTRY_ECR }}

      - name: Login to Registry with login and password
        uses: docker/login-action@v3
        if: github.event_name != 'pull_request' && needs.setup.outputs.use_role != 'true'
        with:
          registry: ${{ secrets.REGISTRY_ECR }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        if: matrix.platform != 'linux/amd64' && matrix.runner == 'ubuntu-latest'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Docker Image
        id: build
        uses: docker/build-push-action@v6
        with:
          provenance: false # fix
          #sbom: false
          file: ${{ inputs.dockerfile }}
          context: ${{ inputs.build_context }}
          build-args: |
            ${{ inputs.build_args }}
            PLATFORM_PAIR=${{ env.PLATFORM_PAIR }}
          annotations: ${{ steps.meta.outputs.annotations }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: ${{ matrix.platform }}
          outputs: type=image,name=${{ env.DOCKER_IMAGE }},push-by-digest=true,name-canonical=true,push=true

      - name: Export digest and push tag
        env:
          SOURCE_IMAGE: "${{ env.DOCKER_IMAGE }}@${{ steps.build.outputs.digest }}"
          TARGET_IMAGE: "${{ env.DOCKER_IMAGE }}:${{ steps.meta.outputs.version }}-${{ env.PLATFORM_PAIR }}"
        run: |
          if [ "${{ inputs.debug }}" = "true" ] ; then
            set -xv
          fi
          mkdir -p ${{ runner.temp }}/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "${{ runner.temp }}/digests/${digest#sha256:}"
          docker pull "${{ env.SOURCE_IMAGE }}"
          docker tag "${{ env.SOURCE_IMAGE }}" "${{ env.TARGET_IMAGE }}"
          docker push "${{ env.TARGET_IMAGE }}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: ${{ needs.setup.outputs.digests_prefix }}-${{ env.PLATFORM_PAIR }}
          path: ${{ runner.temp }}/digests/*
          if-no-files-found: error
          retention-days: 1

  merge:
    runs-on: ubuntu-latest
    needs:
      - setup
      - build_and_push
    steps:
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: ${{ runner.temp }}/digests
          pattern: ${{ needs.setup.outputs.digests_prefix }}-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        if: needs.setup.outputs.use_role == 'true'
        with:
          audience: sts.amazonaws.com
          role-session-name: ${{ github.run_id }}
          role-to-assume: ${{ secrets.ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}

      - name: Login to Registry with role
        uses: docker/login-action@v3
        if: github.event_name != 'pull_request' && needs.setup.outputs.use_role == 'true'
        with:
          registry: ${{ secrets.REGISTRY_ECR }}

      - name: Login to Registry with AK and SK
        uses: docker/login-action@v3
        if: github.event_name != 'pull_request' && needs.setup.outputs.use_role != 'true'
        with:
          registry: ${{ secrets.REGISTRY_ECR }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            ${{ inputs.image_tags }}
            ${{ needs.setup.outputs.image_by_environment }}
          flavor: |
            latest=${{ inputs.image_latest }}
            prefix=${{ inputs.image_tag_prefix }},onlatest=${{ inputs.image_tag_prefix_onlatest }}

      - name: Create manifest list and push
        working-directory: ${{ runner.temp }}/digests
        run: |
          if [ "${{ inputs.debug }}" = "true" ] ; then
            set -xv
          fi
          docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf '${{ env.DOCKER_IMAGE }}@sha256:%s ' *)

      - name: Inspect image
        working-directory: ${{ runner.temp }}/digests
        if: inputs.debug == 'true'
        run: |
          for x in $(jq -cr '.tags | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON"); do
            echo docker buildx imagetools inspect "${x}"
            docker buildx imagetools inspect "${x}"
          done

  deploy_manifest:
    if: inputs.target_repository != ''
    env:
      DEPLOY_APPLICATION: ${{ inputs.target_application }}
      DEPLOY_REPOSITORY: ${{ inputs.target_repository }}
      DEPLOY_PATCH_TARGET: ${{ inputs.target_patch_file }}
      DEPLOY_REPOSITORY_BRANCH: ${{ inputs.target_repository_branch }}
    needs:
      - setup
      - merge
      - build_and_push
    #runs-on: ubuntu-22.04
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        if: needs.setup.outputs.use_role == 'true'
        with:
          audience: sts.amazonaws.com
          role-session-name: ${{ github.run_id }}
          role-to-assume: ${{ secrets.ROLE_ARN }}
          aws-region: ${{ inputs.aws_region }}

      - name: Set VCS token
        id: set-vcs-token
        run: |
          echo "VCS_TOKEN=$(
            aws ssm get-parameter --with-decryption \
              --name ${{ inputs.aws_ssm_name }} \
              | jq -r .Parameter.Value
          )" >> "${GITHUB_OUTPUT}"
        env:
          AWS_DEFAULT_REGION: ${{ inputs.aws_region }}

      - name: Check out Kubernetes Manifests
        uses: actions/checkout@v3
        with:
          ref: ${{ env.DEPLOY_REPOSITORY_BRANCH }}
          repository: ${{ env.DEPLOY_REPOSITORY }}
          #token: ${{ secrets.DEVOPS_GITHUB_PERMANENT_TOKEN }}
          token: ${{ steps.set-vcs-token.outputs.VCS_TOKEN }}
          path: ./deploy-repository/

      - name: Update image on deployment
        working-directory: ./deploy-repository/${{ env.DEPLOY_APPLICATION }}
        env:
          #IMAGE_TAG: ${{ env.DOCKER_IMAGE }}:${{ inputs.image_tag_prefix }}${{ needs.build_and_push.outputs.version }}
          IMAGE_TAG: ${{ env.DOCKER_IMAGE }}:${{ needs.build_and_push.outputs.version }}
          IMAGE_ARCH: ${{ fromJson(inputs.image_arch)[0].platform }}
        run: |
          if [ "${{ inputs.debug }}" = "true" ] ; then
            set -xv
          fi

          which jq > /dev/null 2>&1 || ( sudo apt update; sudo apt install -y jq )

          extver() {
            echo "$1" | sed s'/^.*[v:-]\([0-9]*\.[0-9]*\.[0-9]*\).*$/\1/'g | head -n1
          }

          verlte() {
            [ "$1" = "$(echo -e "$1\n$2" | sort -V | head -n1)" ]
          }

          DEPLOY_ENV_TARGET=$(
            echo ${{ needs.build_and_push.outputs.version }} | grep -Eo 'staging|develop' || echo 'production'
          )

          echo "Target environment: ${DEPLOY_ENV_TARGET}"

          if [ ! -d "${DEPLOY_ENV_TARGET}" ] || [ ! -r "${DEPLOY_ENV_TARGET}/kustomization.yaml" ] || [ ! -r "${DEPLOY_ENV_TARGET}/${{ env.DEPLOY_PATCH_TARGET }}" ]; then
            echo "${DEPLOY_ENV_TARGET}, ${DEPLOY_ENV_TARGET}/kustomization.yaml, or ${DEPLOY_ENV_TARGET}/${{ env.DEPLOY_PATCH_TARGET }}: Not readable, or neither one of those exists"
            exit 1
          else
            CURRENT_IMAGE=$(
              cat "${DEPLOY_ENV_TARGET}/${{ env.DEPLOY_PATCH_TARGET }}" \
                | jq -r '.[] | select(.path == "/spec/template/spec/containers/0/image") | .value'
            )
            CURRENT_VERSION=$(extver "${CURRENT_IMAGE}")
            TARGET_VERSION=$(extver "${{ env.IMAGE_TAG }}")

            echo "Replacing the following image:"
            echo "  Image: ${CURRENT_IMAGE%%:*}"
            echo "  Current version: ${CURRENT_VERSION}"
            echo "  Target version: ${TARGET_VERSION}"

            if verlte "${CURRENT_VERSION}" "${TARGET_VERSION}"; then
              NEW_CONFIG=$(
                jq --arg imageTag "${{ env.IMAGE_TAG }}" '(.. | select(.path == "/spec/template/spec/containers/0/image")?) += {value: $imageTag }' "${DEPLOY_ENV_TARGET}/${{ env.DEPLOY_PATCH_TARGET }}"
              )
              echo "New configuration:"
              echo "${NEW_CONFIG}" | tee "${DEPLOY_ENV_TARGET}/${{ env.DEPLOY_PATCH_TARGET }}"
            else
              echo "Version in file is greater than build, skipping update yaml"
            fi
          fi

      - name: Commit & Push changes
        uses: actions-js/push@master
        with:
          #github_token: ${{ secrets.DEVOPS_GITHUB_PERMANENT_TOKEN }}
          github_token: ${{ steps.set-vcs-token.outputs.VCS_TOKEN }}
          repository: ${{ env.DEPLOY_REPOSITORY }}
          directory: ./deploy-repository/
          branch: ${{ env.DEPLOY_REPOSITORY_BRANCH }}
          #message: "From ${{ github.workflow }}"
          message: "From ${{github.repository}}: ${{ github.workflow }}"
